<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Engram — Memory Graph</title>
<link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #1a1a2e; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; height: 100vh; display: flex; flex-direction: column; }
  #header { padding: 12px 20px; background: #16213e; border-bottom: 1px solid #0f3460; display: flex; align-items: center; gap: 12px; flex-shrink: 0; }
  #header h1 { font-size: 16px; font-weight: 600; color: #a0c4ff; }
  #search { flex: 1; max-width: 300px; padding: 6px 12px; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 6px; color: #e0e0e0; font-size: 13px; outline: none; }
  #search:focus { border-color: #2196F3; }
  #stats { font-size: 12px; color: #888; margin-left: auto; }
  #main { display: flex; flex: 1; overflow: hidden; }
  #graph-container { flex: 1; }
  #panel { width: 260px; background: #16213e; border-left: 1px solid #0f3460; padding: 16px; overflow-y: auto; flex-shrink: 0; display: flex; flex-direction: column; gap: 16px; }
  #panel h2 { font-size: 13px; font-weight: 600; color: #a0c4ff; text-transform: uppercase; letter-spacing: 0.05em; }
  #node-info { font-size: 12px; line-height: 1.6; color: #ccc; }
  #node-info .node-name { font-size: 15px; font-weight: 600; color: #fff; margin-bottom: 6px; }
  #node-info .node-type { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-bottom: 8px; }
  #node-info .attr-row { display: flex; gap: 6px; margin-top: 2px; }
  #node-info .attr-key { color: #888; min-width: 80px; }
  #node-info .edges-title { margin-top: 10px; font-weight: 600; color: #a0c4ff; font-size: 11px; text-transform: uppercase; }
  #node-info .edge-item { padding: 3px 0; border-bottom: 1px solid #0f3460; color: #aaa; }
  #node-info .edge-item span { color: #e0e0e0; }
  #legend { font-size: 12px; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  .legend-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
  #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 14px; }
  #error { display: none; color: #f44336; font-size: 13px; text-align: center; padding: 20px; }
</style>
</head>
<body>
<div id="header">
  <h1>Engram Memory Graph</h1>
  <input id="search" type="text" placeholder="Search nodes..." />
  <div id="stats">Loading...</div>
</div>
<div id="main">
  <div id="graph-container">
    <div id="loading">Loading graph data...</div>
    <div id="error"></div>
  </div>
  <div id="panel">
    <div>
      <h2>Node Details</h2>
      <div id="node-info"><span style="color:#666">Click a node to see details</span></div>
    </div>
    <div>
      <h2>Legend</h2>
      <div id="legend"></div>
    </div>
  </div>
</div>

<script>
const COLOR_MAP = {
  Person: '#4CAF50', Technology: '#2196F3', Project: '#FF9800',
  Service: '#9C27B0', default: '#607D8B'
};

let network = null;
let allNodes = [], allEdges = [];
let nodesDataset, edgesDataset;
let edgeState = new Map();
let nodePrevPos = new Map();
let animRaf = null;
let lastPhysicsTime = 0;
let settledFrames = 0;

async function loadGraph() {
  try {
    const res = await fetch('/api/v1/graph/data');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    allNodes = data.nodes || [];
    allEdges = data.edges || [];
    renderGraph(allNodes, allEdges);
    renderLegend(allNodes);
    updateStats(allNodes.length, allEdges.length);
  } catch (e) {
    document.getElementById('loading').style.display = 'none';
    const err = document.getElementById('error');
    err.style.display = 'block';
    err.textContent = 'Failed to load graph: ' + e.message + '. Make sure engram serve is running.';
  }
}

// XSS defense: escape user-controlled strings before inserting into innerHTML
function esc(s) { const d = document.createElement('div'); d.textContent = String(s); return d.innerHTML; }

function startAnimationLoop() {
  if (animRaf || !network) return;
  settledFrames = 0;
  const tick = () => {
    // Stop loop when edges have settled for 120 frames (~2s)
    if (settledFrames > 120) { animRaf = null; return; }
    network.redraw();
    animRaf = requestAnimationFrame(tick);
  };
  animRaf = requestAnimationFrame(tick);
}

function stopAnimationLoop() {
  if (!animRaf) return;
  cancelAnimationFrame(animRaf);
  animRaf = null;
}

function drawSoftEdges(ctx) {
  if (!network || !allEdges?.length) return;

  // Compute real dt from wall-clock time
  const now = performance.now();
  const dt = lastPhysicsTime
    ? Math.min(0.04, Math.max(0.004, (now - lastPhysicsTime) / 1000))
    : 0.016;
  lastPhysicsTime = now;

  const fanCount = new Map();

  // --- Tunable physics parameters ---
  // K:       spring stiffness for control points (higher = snappier)
  // D:       damping coefficient (critical = 2*sqrt(K) ≈ 31.6; below = wobble)
  // KICK:    node-velocity → control-point impulse factor
  // T_EXP:   exponential tension→straighten rate (higher = straightens faster)
  // R_ADAPT: rest-length adaptation rate when relaxed
  const K = 250;
  const D = 20;
  const KICK = 0.06;
  const T_EXP = 5.0;
  const R_ADAPT = 0.02;

  let totalEnergy = 0;

  for (const e of allEdges) {
    const p1 = network.getPosition(e.from);
    const p2 = network.getPosition(e.to);
    if (!p1 || !p2) continue;

    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 2) continue;

    const ux = dx / dist;
    const uy = dy / dist;
    const nx = -uy;
    const ny = ux;

    // Fan offset for parallel edges between same node pair
    const slot = fanCount.get(e.from) || 0;
    fanCount.set(e.from, slot + 1);
    const alt = slot % 2 === 0 ? 1 : -1;
    const baseOffset = alt * (5 + slot * 0.8);

    // Node velocities (pixels/second) from previous-frame positions
    const prev1 = nodePrevPos.get(e.from) || p1;
    const prev2 = nodePrevPos.get(e.to) || p2;
    const v1x = (p1.x - prev1.x) / dt;
    const v1y = (p1.y - prev1.y) / dt;
    const v2x = (p2.x - prev2.x) / dt;
    const v2y = (p2.y - prev2.y) / dt;
    const nodeSpeed = Math.hypot(v1x, v1y) + Math.hypot(v2x, v2y);

    const key = `${e.from}->${e.to}:${e.label}`;
    let st = edgeState.get(key);
    if (!st) {
      st = {
        rest: dist,
        c1x: p1.x + dx * 0.33 + nx * baseOffset,
        c1y: p1.y + dy * 0.33 + ny * baseOffset,
        c2x: p1.x + dx * 0.67 + nx * (baseOffset * 0.5),
        c2y: p1.y + dy * 0.67 + ny * (baseOffset * 0.5),
        c1vx: 0, c1vy: 0, c2vx: 0, c2vy: 0,
      };
      edgeState.set(key, st);
    }

    // Adapt rest length slowly when nodes are nearly still
    if (nodeSpeed < 20) {
      st.rest += (dist - st.rest) * R_ADAPT;
    }

    // Tension: how far stretched beyond rest length (0 = relaxed)
    const stretch = dist / Math.max(1, st.rest);
    const tension = Math.max(0, stretch - 1);

    // Exponential straightening: curvature decays fast under tension
    // tension=0 → 1.0, tension=0.2 → 0.37, tension=0.5 → 0.08
    const curveFactor = Math.exp(-tension * T_EXP);

    const offset = baseOffset * curveFactor;

    // Target control points: curved when relaxed, straight when tense
    const t1x = p1.x + dx * 0.33 + nx * offset;
    const t1y = p1.y + dy * 0.33 + ny * offset;
    const t2x = p1.x + dx * 0.67 + nx * (offset * 0.5);
    const t2y = p1.y + dy * 0.67 + ny * (offset * 0.5);

    // Kick: node movement → lateral impulse on control-point velocities
    // This produces natural wobble from actual motion, not canned sine
    const nKick1 = (v1x * nx + v1y * ny) * KICK;
    const nKick2 = (v2x * nx + v2y * ny) * KICK;

    // Semi-implicit Euler spring-damper integration
    // acc = -K * (pos - target) - D * vel
    // vel += acc * dt + kick;  pos += vel * dt
    const a1x = -K * (st.c1x - t1x) - D * st.c1vx;
    const a1y = -K * (st.c1y - t1y) - D * st.c1vy;
    st.c1vx += a1x * dt + nx * nKick1;
    st.c1vy += a1y * dt + ny * nKick1;
    st.c1x += st.c1vx * dt;
    st.c1y += st.c1vy * dt;

    const a2x = -K * (st.c2x - t2x) - D * st.c2vx;
    const a2y = -K * (st.c2y - t2y) - D * st.c2vy;
    st.c2vx += a2x * dt + nx * nKick2;
    st.c2vy += a2y * dt + ny * nKick2;
    st.c2x += st.c2vx * dt;
    st.c2y += st.c2vy * dt;

    // Track total kinetic energy for settling detection
    totalEnergy += st.c1vx * st.c1vx + st.c1vy * st.c1vy
                 + st.c2vx * st.c2vx + st.c2vy * st.c2vy
                 + nodeSpeed * nodeSpeed * 0.0001;

    // Draw the bezier edge
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.bezierCurveTo(st.c1x, st.c1y, st.c2x, st.c2y, p2.x, p2.y);
    ctx.lineCap = 'round';
    ctx.strokeStyle = 'rgba(255,157,47,0.62)';
    ctx.lineWidth = 0.95 + Math.min(1.1, (e.weight || 1) * 0.2);
    ctx.shadowColor = 'rgba(255,157,47,0.22)';
    ctx.shadowBlur = 2.4;
    ctx.stroke();
    ctx.restore();
  }

  // Store current positions for next-frame velocity computation
  for (const n of allNodes) {
    const p = network.getPosition(n.id);
    if (p) nodePrevPos.set(n.id, { x: p.x, y: p.y });
  }

  // Settling detection: stop animation loop when energy is negligible
  if (totalEnergy < 0.5) settledFrames++;
  else settledFrames = 0;
}

function renderGraph(nodes, edges) {
  document.getElementById('loading').style.display = 'none';

  const cs = getComputedStyle(document.documentElement);
  const textColor = cs.getPropertyValue('--text-primary')?.trim() || '#e0e0e0';
  const mutedColor = cs.getPropertyValue('--text-muted')?.trim() || '#aaa';
  const borderColor = cs.getPropertyValue('--border')?.trim() || '#334';
  const accentColor = cs.getPropertyValue('--accent')?.trim() || '#2196F3';

  nodesDataset = new vis.DataSet(nodes.map(n => ({
    ...n,
    font: { color: textColor, size: 12 },
    borderWidth: 1,
    borderWidthSelected: 2,
  })));
  edgesDataset = new vis.DataSet(edges.map(e => ({
    ...e,
    font: { color: mutedColor, size: 10, align: 'middle' },
    // Ẩn line mặc định, chỉ dùng cho label + interaction
    color: {
      color: 'rgba(0,0,0,0)',
      hover: 'rgba(0,0,0,0)',
      highlight: 'rgba(0,0,0,0)',
      inherit: false,
    },
    smooth: false,
    width: 1,
    hoverWidth: 0,
    selectionWidth: 0,
    chosen: false,
  })));

  const container = document.getElementById('graph-container');
  const options = {
    physics: {
      enabled: true,
      forceAtlas2Based: { gravitationalConstant: -50, springLength: 100, springConstant: 0.08 },
      solver: 'forceAtlas2Based',
      stabilization: { iterations: 150 },
    },
    interaction: { hover: true, tooltipDelay: 200 },
    nodes: { shape: 'dot', size: 16 },
    edges: {
      arrows: { to: { enabled: false } },
      smooth: false,
      color: {
        color: 'rgba(0,0,0,0)',
        hover: 'rgba(0,0,0,0)',
        highlight: 'rgba(0,0,0,0)',
        inherit: false,
      },
      hoverWidth: 0,
      selectionWidth: 0,
    },
    background: { color: '#1a1a2e' },
  };

  network = new vis.Network(container, { nodes: nodesDataset, edges: edgesDataset }, options);
  edgeState = new Map();
  nodePrevPos = new Map();
  network.on('beforeDrawing', drawSoftEdges);
  startAnimationLoop();

  // Restart animation on any interaction that moves nodes
  network.on('dragStart', () => startAnimationLoop());
  network.on('zoom', () => startAnimationLoop());
  network.on('startStabilizing', () => startAnimationLoop());

  network.on('click', params => {
    if (params.nodes.length > 0) showNodeDetails(params.nodes[0]);
    else clearNodeDetails();
  });
}

function showNodeDetails(nodeId) {
  const node = allNodes.find(n => n.id === nodeId);
  if (!node) return;

  const connectedEdges = allEdges.filter(e => e.from === nodeId || e.to === nodeId);
  const color = COLOR_MAP[node.group] || COLOR_MAP.default;

  let html = `<div class="node-name">${esc(node.label)}</div>`;
  html += `<span class="node-type" style="background:${color}22;color:${color};border:1px solid ${color}44">${esc(node.group)}</span>`;

  // Parse tooltip for attributes
  const lines = (node.title || '').split('\n').slice(1);
  if (lines.length > 0) {
    html += '<div style="margin-top:6px">';
    for (const line of lines) {
      if (!line.trim()) continue;
      const [k, ...rest] = line.split(':');
      html += `<div class="attr-row"><span class="attr-key">${esc(k)}:</span><span>${esc(rest.join(':').trim())}</span></div>`;
    }
    html += '</div>';
  }

  if (connectedEdges.length > 0) {
    html += `<div class="edges-title">Connections (${connectedEdges.length})</div>`;
    connectedEdges.slice(0, 10).forEach(e => {
      const dir = e.from === nodeId ? '→' : '←';
      const otherId = e.from === nodeId ? e.to : e.from;
      const other = allNodes.find(n => n.id === otherId);
      const otherLabel = other ? other.label : otherId;
      html += `<div class="edge-item">${dir} <span>${esc(e.label)}</span> ${esc(otherLabel)}</div>`;
    });
    if (connectedEdges.length > 10) html += `<div style="color:#666;margin-top:4px">+${connectedEdges.length - 10} more</div>`;
  }

  document.getElementById('node-info').innerHTML = html;
}

function clearNodeDetails() {
  document.getElementById('node-info').innerHTML = '<span style="color:#666">Click a node to see details</span>';
}

function renderLegend(nodes) {
  const types = [...new Set(nodes.map(n => n.group))].sort();
  const container = document.getElementById('legend');
  container.innerHTML = types.map(t => {
    const color = COLOR_MAP[t] || COLOR_MAP.default;
    return `<div class="legend-item"><div class="legend-dot" style="background:${color}"></div><span>${esc(t)}</span></div>`;
  }).join('') || '<span style="color:#666">No nodes</span>';
}

function updateStats(nodeCount, edgeCount) {
  document.getElementById('stats').textContent = `${nodeCount} nodes · ${edgeCount} edges`;
}

document.getElementById('search').addEventListener('input', e => {
  const q = e.target.value.trim().toLowerCase();
  if (!network || !nodesDataset) return;

  if (!q) {
    nodesDataset.update(allNodes.map(n => ({ id: n.id, opacity: 1 })));
    return;
  }

  const matched = new Set(allNodes.filter(n => n.label.toLowerCase().includes(q)).map(n => n.id));
  nodesDataset.update(allNodes.map(n => ({
    id: n.id,
    opacity: matched.has(n.id) ? 1 : 0.15,
    borderWidth: matched.has(n.id) ? 3 : 1,
  })));

  if (matched.size > 0) network.fit({ nodes: [...matched], animation: true });
});

document.addEventListener('visibilitychange', () => {
  if (document.hidden) stopAnimationLoop();
  else startAnimationLoop();
});
window.addEventListener('pagehide', stopAnimationLoop);

loadGraph();
</script>
</body>
</html>
