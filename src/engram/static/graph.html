<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Engram — Memory Graph</title>
<link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #1a1a2e; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; height: 100vh; display: flex; flex-direction: column; }
  #header { padding: 12px 20px; background: #16213e; border-bottom: 1px solid #0f3460; display: flex; align-items: center; gap: 12px; flex-shrink: 0; }
  #header h1 { font-size: 16px; font-weight: 600; color: #a0c4ff; }
  #search { flex: 1; max-width: 300px; padding: 6px 12px; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 6px; color: #e0e0e0; font-size: 13px; outline: none; }
  #search:focus { border-color: #2196F3; }
  #stats { font-size: 12px; color: #888; margin-left: auto; }
  #main { display: flex; flex: 1; overflow: hidden; }
  #graph-container { flex: 1; }
  #panel { width: 260px; background: #16213e; border-left: 1px solid #0f3460; padding: 16px; overflow-y: auto; flex-shrink: 0; display: flex; flex-direction: column; gap: 16px; }
  #panel h2 { font-size: 13px; font-weight: 600; color: #a0c4ff; text-transform: uppercase; letter-spacing: 0.05em; }
  #node-info { font-size: 12px; line-height: 1.6; color: #ccc; }
  #node-info .node-name { font-size: 15px; font-weight: 600; color: #fff; margin-bottom: 6px; }
  #node-info .node-type { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-bottom: 8px; }
  #node-info .attr-row { display: flex; gap: 6px; margin-top: 2px; }
  #node-info .attr-key { color: #888; min-width: 80px; }
  #node-info .edges-title { margin-top: 10px; font-weight: 600; color: #a0c4ff; font-size: 11px; text-transform: uppercase; }
  #node-info .edge-item { padding: 3px 0; border-bottom: 1px solid #0f3460; color: #aaa; }
  #node-info .edge-item span { color: #e0e0e0; }
  #legend { font-size: 12px; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  .legend-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
  #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 14px; }
  #error { display: none; color: #f44336; font-size: 13px; text-align: center; padding: 20px; }
</style>
</head>
<body>
<div id="header">
  <h1>Engram Memory Graph</h1>
  <input id="search" type="text" placeholder="Search nodes..." />
  <div id="stats">Loading...</div>
</div>
<div id="main">
  <div id="graph-container">
    <div id="loading">Loading graph data...</div>
    <div id="error"></div>
  </div>
  <div id="panel">
    <div>
      <h2>Node Details</h2>
      <div id="node-info"><span style="color:#666">Click a node to see details</span></div>
    </div>
    <div>
      <h2>Legend</h2>
      <div id="legend"></div>
    </div>
  </div>
</div>

<script>
// ─── EDGE PHYSICS TUNING CONSTANTS ─────────────────────────────────
// All edge dynamics are driven by a 1D spring-damper per control point
// operating in the edge-normal direction (perpendicular to the line
// connecting the two endpoint nodes). This keeps the model simple:
// one scalar offset per control point instead of 2D absolute coords.
//
// Spring stiffness (N/m equivalent). Higher = control points snap back faster.
const SPRING_K = 35;
// Damping coefficient. Critical damping = 2*sqrt(K) ≈ 11.8.
// Below critical → oscillation (bouncy). Above → overdamped (sluggish).
const SPRING_D = 10;
// Node-drag velocity → control-point impulse gain. Higher = edges react
// more dramatically to fast drags.
const DRAG_IMPULSE = 1.6;
// Tension straightening rate. The bend factor decays as exp(-tension * this).
// Higher = edges straighten faster when stretched beyond rest length.
const TENSION_RATE = 5.0;
// Base curvature (px) for the first parallel edge in a fan group.
const BASE_CURVE = 5.0;
// Additional curvature per fan slot (px) for parallel edges.
const SLOT_CURVE = 0.8;
// How fast rest length adapts to current distance (0=frozen, 1=instant).
// Low values give a "rubber band" memory effect.
const REST_ADAPT = 0.008;
// Minimum bend factor to prevent edges from going fully straight (z-fight).
const MIN_BEND = 0.01;
// Frames of near-zero energy before animation loop auto-sleeps.
const SLEEP_AFTER = 90;
// ────────────────────────────────────────────────────────────────────

const COLOR_MAP = {
  Person: '#4CAF50', Technology: '#2196F3', Project: '#FF9800',
  Service: '#9C27B0', default: '#607D8B'
};

let network = null;
let allNodes = [], allEdges = [];
let nodesDataset, edgesDataset;
let edgeState = new Map();
let nodePrevPos = new Map();
let animRaf = null;
let quietFrames = 0;

async function loadGraph() {
  try {
    const res = await fetch('/api/v1/graph/data');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    allNodes = data.nodes || [];
    allEdges = data.edges || [];
    renderGraph(allNodes, allEdges);
    renderLegend(allNodes);
    updateStats(allNodes.length, allEdges.length);
  } catch (e) {
    document.getElementById('loading').style.display = 'none';
    const err = document.getElementById('error');
    err.style.display = 'block';
    err.textContent = 'Failed to load graph: ' + e.message + '. Make sure engram serve is running.';
  }
}

// XSS defense: escape user-controlled strings before inserting into innerHTML
function esc(s) { const d = document.createElement('div'); d.textContent = String(s); return d.innerHTML; }

function wakeLoop() {
  quietFrames = 0;
  startAnimationLoop();
}

function startAnimationLoop() {
  if (animRaf || !network) return;
  quietFrames = 0;
  const tick = () => {
    if (quietFrames > SLEEP_AFTER) { animRaf = null; return; }
    network.redraw();
    animRaf = requestAnimationFrame(tick);
  };
  animRaf = requestAnimationFrame(tick);
}

function stopAnimationLoop() {
  if (!animRaf) return;
  cancelAnimationFrame(animRaf);
  animRaf = null;
}

function drawSoftEdges(ctx) {
  if (!network || !allEdges?.length) return;

  // Fixed physics timestep for stability (independent of frame rate)
  const dt = 1 / 60;
  const dampFactor = Math.exp(-SPRING_D * dt);

  // Batch-read all node positions and compute velocities once
  const nodePos = new Map();
  const nodeVel = new Map();
  for (const n of allNodes) {
    const p = network.getPosition(n.id);
    if (!p) continue;
    nodePos.set(n.id, p);
    const prev = nodePrevPos.get(n.id);
    if (prev) {
      nodeVel.set(n.id, { x: p.x - prev.x, y: p.y - prev.y });
    }
  }

  // Count parallel edges between each node pair for fanning
  const fanSlot = new Map();
  let totalEnergy = 0;

  // Set shared canvas state once (major perf win: no per-edge save/restore)
  ctx.save();
  ctx.lineCap = 'round';
  ctx.strokeStyle = 'rgba(255,157,47,0.6)';
  ctx.shadowColor = 'rgba(255,157,47,0.15)';
  ctx.shadowBlur = 2;

  for (const e of allEdges) {
    const p1 = nodePos.get(e.from);
    const p2 = nodePos.get(e.to);
    if (!p1 || !p2) continue;

    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 1) continue;

    const invDist = 1 / dist;
    const nx = -dy * invDist;  // normal (perpendicular to edge)
    const ny = dx * invDist;

    // Fan slot: sort pair key so A→B and B→A share the same fan group
    const pairKey = e.from < e.to ? `${e.from}|${e.to}` : `${e.to}|${e.from}`;
    const slot = fanSlot.get(pairKey) || 0;
    fanSlot.set(pairKey, slot + 1);
    const alt = slot % 2 === 0 ? 1 : -1;

    // Per-edge state: two scalar offsets (normal-direction displacement)
    // and their velocities. This 1D model is cheaper and more stable
    // than tracking 2D absolute control-point positions.
    const key = `${e.from}->${e.to}:${e.label}`;
    let st = edgeState.get(key);
    if (!st) {
      const nom = alt * (BASE_CURVE + slot * SLOT_CURVE);
      st = { rest: dist, off1: nom, off2: nom * 0.5, vel1: 0, vel2: 0 };
      edgeState.set(key, st);
    }

    // Node velocities (frame-delta px, not px/s — avoids dt division noise)
    const v1 = nodeVel.get(e.from) || { x: 0, y: 0 };
    const v2 = nodeVel.get(e.to) || { x: 0, y: 0 };
    const nodeSpeed = Math.abs(v1.x) + Math.abs(v1.y) + Math.abs(v2.x) + Math.abs(v2.y);

    // Adapt rest length slowly when nodes are near-stationary
    if (nodeSpeed < 0.5) {
      st.rest += (dist - st.rest) * REST_ADAPT;
    }

    // Tension: how much the edge is stretched beyond rest length
    const stretch = dist / Math.max(1, st.rest);
    const tension = Math.max(0, stretch - 1);

    // Smooth exponential straightening under tension
    const bendScale = Math.max(MIN_BEND, Math.exp(-tension * TENSION_RATE));

    // Target offsets: nominal curvature scaled by bend factor
    const nominalOff = alt * (BASE_CURVE + slot * SLOT_CURVE);
    const target1 = nominalOff * bendScale;
    const target2 = nominalOff * 0.5 * bendScale;

    // Drag impulse: project average node velocity onto edge normal.
    // This is what produces the physical "wobble" from dragging.
    const avgVn = ((v1.x + v2.x) * nx + (v1.y + v2.y) * ny) * 0.5;
    const impulse = avgVn * DRAG_IMPULSE;

    // Under high tension, boost effective stiffness so edges snap straight faster
    const kEff = SPRING_K * (1 + tension * 4);

    // Semi-implicit Euler: update velocity then position
    // acc = -k * (offset - target) ; vel = (vel + acc*dt + impulse) * damp
    st.vel1 = (st.vel1 + (target1 - st.off1) * kEff * dt + impulse) * dampFactor;
    st.vel2 = (st.vel2 + (target2 - st.off2) * kEff * dt + impulse * 0.6) * dampFactor;
    st.off1 += st.vel1 * dt;
    st.off2 += st.vel2 * dt;

    totalEnergy += st.vel1 * st.vel1 + st.vel2 * st.vel2;

    // Convert 1D normal offsets → absolute control-point coordinates
    const c1x = p1.x + dx * 0.33 + nx * st.off1;
    const c1y = p1.y + dy * 0.33 + ny * st.off1;
    const c2x = p1.x + dx * 0.67 + nx * st.off2;
    const c2y = p1.y + dy * 0.67 + ny * st.off2;

    // Single bezier stroke — no double-draw, no separate glow pass
    ctx.lineWidth = 0.9 + Math.min(1.0, (e.weight || 1) * 0.2);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.bezierCurveTo(c1x, c1y, c2x, c2y, p2.x, p2.y);
    ctx.stroke();
  }

  ctx.restore();

  // Add node motion energy for settling detection
  for (const [, v] of nodeVel) {
    totalEnergy += v.x * v.x + v.y * v.y;
  }

  // Store positions for next frame's velocity computation
  for (const [id, p] of nodePos) {
    nodePrevPos.set(id, { x: p.x, y: p.y });
  }

  // Settling: count consecutive low-energy frames
  if (totalEnergy < 0.1) quietFrames++;
  else quietFrames = 0;
}

function renderGraph(nodes, edges) {
  document.getElementById('loading').style.display = 'none';

  const cs = getComputedStyle(document.documentElement);
  const textColor = cs.getPropertyValue('--text-primary')?.trim() || '#e0e0e0';
  const mutedColor = cs.getPropertyValue('--text-muted')?.trim() || '#aaa';

  nodesDataset = new vis.DataSet(nodes.map(n => ({
    ...n,
    font: { color: textColor, size: 12 },
    borderWidth: 1,
    borderWidthSelected: 2,
  })));
  edgesDataset = new vis.DataSet(edges.map(e => ({
    ...e,
    font: { color: mutedColor, size: 10, align: 'middle' },
    color: {
      color: 'rgba(0,0,0,0)',
      hover: 'rgba(0,0,0,0)',
      highlight: 'rgba(0,0,0,0)',
      inherit: false,
    },
    smooth: false,
    width: 1,
    hoverWidth: 0,
    selectionWidth: 0,
    chosen: false,
  })));

  const container = document.getElementById('graph-container');
  const options = {
    physics: {
      enabled: true,
      forceAtlas2Based: { gravitationalConstant: -50, springLength: 100, springConstant: 0.08 },
      solver: 'forceAtlas2Based',
      stabilization: { iterations: 150 },
    },
    interaction: { hover: true, tooltipDelay: 200 },
    nodes: { shape: 'dot', size: 16 },
    edges: {
      arrows: { to: { enabled: false } },
      smooth: false,
      color: {
        color: 'rgba(0,0,0,0)',
        hover: 'rgba(0,0,0,0)',
        highlight: 'rgba(0,0,0,0)',
        inherit: false,
      },
      hoverWidth: 0,
      selectionWidth: 0,
    },
    background: { color: '#1a1a2e' },
  };

  network = new vis.Network(container, { nodes: nodesDataset, edges: edgesDataset }, options);
  edgeState = new Map();
  nodePrevPos = new Map();
  network.on('beforeDrawing', drawSoftEdges);
  startAnimationLoop();

  // Wake animation on any interaction that moves nodes
  network.on('dragStart', wakeLoop);
  network.on('zoom', wakeLoop);
  network.on('startStabilizing', wakeLoop);

  network.on('click', params => {
    wakeLoop();
    if (params.nodes.length > 0) showNodeDetails(params.nodes[0]);
    else clearNodeDetails();
  });
}

function showNodeDetails(nodeId) {
  const node = allNodes.find(n => n.id === nodeId);
  if (!node) return;

  const connectedEdges = allEdges.filter(e => e.from === nodeId || e.to === nodeId);
  const color = COLOR_MAP[node.group] || COLOR_MAP.default;

  let html = `<div class="node-name">${esc(node.label)}</div>`;
  html += `<span class="node-type" style="background:${color}22;color:${color};border:1px solid ${color}44">${esc(node.group)}</span>`;

  const lines = (node.title || '').split('\n').slice(1);
  if (lines.length > 0) {
    html += '<div style="margin-top:6px">';
    for (const line of lines) {
      if (!line.trim()) continue;
      const [k, ...rest] = line.split(':');
      html += `<div class="attr-row"><span class="attr-key">${esc(k)}:</span><span>${esc(rest.join(':').trim())}</span></div>`;
    }
    html += '</div>';
  }

  if (connectedEdges.length > 0) {
    html += `<div class="edges-title">Connections (${connectedEdges.length})</div>`;
    connectedEdges.slice(0, 10).forEach(e => {
      const dir = e.from === nodeId ? '→' : '←';
      const otherId = e.from === nodeId ? e.to : e.from;
      const other = allNodes.find(n => n.id === otherId);
      const otherLabel = other ? other.label : otherId;
      html += `<div class="edge-item">${dir} <span>${esc(e.label)}</span> ${esc(otherLabel)}</div>`;
    });
    if (connectedEdges.length > 10) html += `<div style="color:#666;margin-top:4px">+${connectedEdges.length - 10} more</div>`;
  }

  document.getElementById('node-info').innerHTML = html;
}

function clearNodeDetails() {
  document.getElementById('node-info').innerHTML = '<span style="color:#666">Click a node to see details</span>';
}

function renderLegend(nodes) {
  const types = [...new Set(nodes.map(n => n.group))].sort();
  const container = document.getElementById('legend');
  container.innerHTML = types.map(t => {
    const color = COLOR_MAP[t] || COLOR_MAP.default;
    return `<div class="legend-item"><div class="legend-dot" style="background:${color}"></div><span>${esc(t)}</span></div>`;
  }).join('') || '<span style="color:#666">No nodes</span>';
}

function updateStats(nodeCount, edgeCount) {
  document.getElementById('stats').textContent = `${nodeCount} nodes · ${edgeCount} edges`;
}

document.getElementById('search').addEventListener('input', e => {
  const q = e.target.value.trim().toLowerCase();
  if (!network || !nodesDataset) return;

  if (!q) {
    nodesDataset.update(allNodes.map(n => ({ id: n.id, opacity: 1 })));
    return;
  }

  const matched = new Set(allNodes.filter(n => n.label.toLowerCase().includes(q)).map(n => n.id));
  nodesDataset.update(allNodes.map(n => ({
    id: n.id,
    opacity: matched.has(n.id) ? 1 : 0.15,
    borderWidth: matched.has(n.id) ? 3 : 1,
  })));

  if (matched.size > 0) network.fit({ nodes: [...matched], animation: true });
});

document.addEventListener('visibilitychange', () => {
  if (document.hidden) stopAnimationLoop();
  else wakeLoop();
});
window.addEventListener('pagehide', stopAnimationLoop);

loadGraph();
</script>
</body>
</html>
