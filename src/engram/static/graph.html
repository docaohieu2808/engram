<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Engram — Memory Graph</title>
<link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #1a1a2e; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; height: 100vh; display: flex; flex-direction: column; }
  #header { padding: 12px 20px; background: #16213e; border-bottom: 1px solid #0f3460; display: flex; align-items: center; gap: 12px; flex-shrink: 0; }
  #header h1 { font-size: 16px; font-weight: 600; color: #a0c4ff; }
  #search { flex: 1; max-width: 300px; padding: 6px 12px; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 6px; color: #e0e0e0; font-size: 13px; outline: none; }
  #search:focus { border-color: #2196F3; }
  #stats { font-size: 12px; color: #888; margin-left: auto; }
  #main { display: flex; flex: 1; overflow: hidden; }
  #graph-container { flex: 1; }
  #panel { width: 260px; background: #16213e; border-left: 1px solid #0f3460; padding: 16px; overflow-y: auto; flex-shrink: 0; display: flex; flex-direction: column; gap: 16px; }
  #panel h2 { font-size: 13px; font-weight: 600; color: #a0c4ff; text-transform: uppercase; letter-spacing: 0.05em; }
  #node-info { font-size: 12px; line-height: 1.6; color: #ccc; }
  #node-info .node-name { font-size: 15px; font-weight: 600; color: #fff; margin-bottom: 6px; }
  #node-info .node-type { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-bottom: 8px; }
  #node-info .attr-row { display: flex; gap: 6px; margin-top: 2px; }
  #node-info .attr-key { color: #888; min-width: 80px; }
  #node-info .edges-title { margin-top: 10px; font-weight: 600; color: #a0c4ff; font-size: 11px; text-transform: uppercase; }
  #node-info .edge-item { padding: 3px 0; border-bottom: 1px solid #0f3460; color: #aaa; }
  #node-info .edge-item span { color: #e0e0e0; }
  #legend { font-size: 12px; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  .legend-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
  #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 14px; }
  #error { display: none; color: #f44336; font-size: 13px; text-align: center; padding: 20px; }
</style>
</head>
<body>
<div id="header">
  <h1>Engram Memory Graph</h1>
  <input id="search" type="text" placeholder="Search nodes..." />
  <div id="stats">Loading...</div>
</div>
<div id="main">
  <div id="graph-container">
    <div id="loading">Loading graph data...</div>
    <div id="error"></div>
  </div>
  <div id="panel">
    <div>
      <h2>Node Details</h2>
      <div id="node-info"><span style="color:#666">Click a node to see details</span></div>
    </div>
    <div>
      <h2>Legend</h2>
      <div id="legend"></div>
    </div>
  </div>
</div>

<script>
const COLOR_MAP = {
  Person: '#4CAF50', Technology: '#2196F3', Project: '#FF9800',
  Service: '#9C27B0', default: '#607D8B'
};

let network = null;
let allNodes = [], allEdges = [];
let nodesDataset, edgesDataset;
let edgeState = new Map();
let nodePrevPos = new Map();
let animRaf = null;
let lastFrame = 0;
let animTime = 0;

async function loadGraph() {
  try {
    const res = await fetch('/api/v1/graph/data');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    allNodes = data.nodes || [];
    allEdges = data.edges || [];
    renderGraph(allNodes, allEdges);
    renderLegend(allNodes);
    updateStats(allNodes.length, allEdges.length);
  } catch (e) {
    document.getElementById('loading').style.display = 'none';
    const err = document.getElementById('error');
    err.style.display = 'block';
    err.textContent = 'Failed to load graph: ' + e.message + '. Make sure engram serve is running.';
  }
}

// XSS defense: escape user-controlled strings before inserting into innerHTML
function esc(s) { const d = document.createElement('div'); d.textContent = String(s); return d.innerHTML; }

function stableSeed(text) {
  let h = 2166136261;
  for (let i = 0; i < text.length; i += 1) {
    h ^= text.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0) || 1;
}

function startAnimationLoop() {
  if (animRaf || !network) return;
  const tick = (ts) => {
    const now = ts || performance.now();
    const dt = Math.min(0.05, Math.max(0.008, (now - (lastFrame || now)) / 1000));
    lastFrame = now;
    animTime += dt;

    // khi physics đang chạy hoặc vừa kéo node, redraw để edge có độ "lắc"
    network.redraw();
    animRaf = requestAnimationFrame(tick);
  };
  animRaf = requestAnimationFrame(tick);
}

function stopAnimationLoop() {
  if (!animRaf) return;
  cancelAnimationFrame(animRaf);
  animRaf = null;
}

function drawSoftEdges(ctx) {
  if (!network || !allEdges?.length) return;

  const fanCount = new Map();
  const dt = 1 / 60;

  // tham số "dẻo như chỉ"
  const kCtrl = 30;      // lò xo control points (thấp hơn = dẻo hơn)
  const dCtrl = 7.5;     // giảm chấn control points
  const kick = 2.2;      // lực bơm từ kéo node

  for (const e of allEdges) {
    const p1 = network.getPosition(e.from);
    const p2 = network.getPosition(e.to);
    if (!p1 || !p2) continue;

    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 2) continue;

    const ux = dx / dist;
    const uy = dy / dist;
    const nx = -uy;
    const ny = ux;

    const slot = fanCount.get(e.from) || 0;
    fanCount.set(e.from, slot + 1);

    const seed = stableSeed(`${e.from}|${e.label}|${e.to}`);
    const alt = slot % 2 === 0 ? 1 : -1;

    const prev1 = nodePrevPos.get(e.from) || p1;
    const prev2 = nodePrevPos.get(e.to) || p2;
    const v1x = p1.x - prev1.x;
    const v1y = p1.y - prev1.y;
    const v2x = p2.x - prev2.x;
    const v2y = p2.y - prev2.y;

    // điểm neo mục tiêu của 2 control points (1/3 và 2/3 cạnh)
    const base = alt * Math.min(26, 5 + slot * 0.95 + dist * 0.014);
    const c1tx = p1.x + dx * 0.34 + nx * base;
    const c1ty = p1.y + dy * 0.34 + ny * base;
    const c2tx = p1.x + dx * 0.68 + nx * (base * 0.5);
    const c2ty = p1.y + dy * 0.68 + ny * (base * 0.5);

    const key = `${e.from}->${e.to}:${e.label}`;
    let st = edgeState.get(key);
    if (!st) {
      st = {
        c1x: c1tx, c1y: c1ty, c2x: c2tx, c2y: c2ty,
        c1vx: 0, c1vy: 0, c2vx: 0, c2vy: 0,
      };
      edgeState.set(key, st);
    }

    // lực kích thích khi node bị kéo: chiếu vận tốc lên pháp tuyến
    const exciteN = ((v1x + v2x) * nx + (v1y + v2y) * ny) * kick;
    const exciteT = ((v2x - v1x) * ux + (v2y - v1y) * uy) * (kick * 0.65);

    const tc1x = c1tx + nx * exciteN + ux * exciteT;
    const tc1y = c1ty + ny * exciteN + uy * exciteT;
    const tc2x = c2tx + nx * (exciteN * 0.6) - ux * (exciteT * 0.55);
    const tc2y = c2ty + ny * (exciteN * 0.6) - uy * (exciteT * 0.55);

    // spring-damper cho c1
    st.c1vx += (tc1x - st.c1x) * kCtrl * dt;
    st.c1vy += (tc1y - st.c1y) * kCtrl * dt;
    st.c1vx *= Math.exp(-dCtrl * dt);
    st.c1vy *= Math.exp(-dCtrl * dt);
    st.c1x += st.c1vx * dt * 60;
    st.c1y += st.c1vy * dt * 60;

    // spring-damper cho c2
    st.c2vx += (tc2x - st.c2x) * kCtrl * dt;
    st.c2vy += (tc2y - st.c2y) * kCtrl * dt;
    st.c2vx *= Math.exp(-dCtrl * dt);
    st.c2vy *= Math.exp(-dCtrl * dt);
    st.c2x += st.c2vx * dt * 60;
    st.c2y += st.c2vy * dt * 60;

    // micro jitter rất nhỏ để tránh cảm giác "đường chết"
    const jitter = Math.sin(animTime * (1 + ((seed >> 2) % 30) / 100) + (seed % 100) * 0.03) * 0.6;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.bezierCurveTo(st.c1x + nx * jitter, st.c1y + ny * jitter, st.c2x - nx * jitter, st.c2y - ny * jitter, p2.x, p2.y);
    ctx.lineCap = 'round';
    ctx.strokeStyle = 'rgba(255,157,47,0.62)';
    ctx.lineWidth = 0.95 + Math.min(1.1, (e.weight || 1) * 0.2);
    ctx.shadowColor = 'rgba(255,157,47,0.22)';
    ctx.shadowBlur = 2.4;
    ctx.stroke();
    ctx.restore();
  }

  for (const n of allNodes) {
    const p = network.getPosition(n.id);
    if (p) nodePrevPos.set(n.id, { x: p.x, y: p.y });
  }
}

function renderGraph(nodes, edges) {
  document.getElementById('loading').style.display = 'none';

  const cs = getComputedStyle(document.documentElement);
  const textColor = cs.getPropertyValue('--text-primary')?.trim() || '#e0e0e0';
  const mutedColor = cs.getPropertyValue('--text-muted')?.trim() || '#aaa';
  const borderColor = cs.getPropertyValue('--border')?.trim() || '#334';
  const accentColor = cs.getPropertyValue('--accent')?.trim() || '#2196F3';

  nodesDataset = new vis.DataSet(nodes.map(n => ({
    ...n,
    font: { color: textColor, size: 12 },
    borderWidth: 1,
    borderWidthSelected: 2,
  })));
  edgesDataset = new vis.DataSet(edges.map(e => ({
    ...e,
    font: { color: mutedColor, size: 10, align: 'middle' },
    // Ẩn line mặc định, chỉ dùng cho label + interaction
    color: {
      color: 'rgba(0,0,0,0)',
      hover: 'rgba(0,0,0,0)',
      highlight: 'rgba(0,0,0,0)',
      inherit: false,
    },
    smooth: false,
    width: 1,
    hoverWidth: 0,
    selectionWidth: 0,
    chosen: false,
  })));

  const container = document.getElementById('graph-container');
  const options = {
    physics: {
      enabled: true,
      forceAtlas2Based: { gravitationalConstant: -50, springLength: 100, springConstant: 0.08 },
      solver: 'forceAtlas2Based',
      stabilization: { iterations: 150 },
    },
    interaction: { hover: true, tooltipDelay: 200 },
    nodes: { shape: 'dot', size: 16 },
    edges: {
      arrows: { to: { enabled: false } },
      smooth: false,
      color: {
        color: 'rgba(0,0,0,0)',
        hover: 'rgba(0,0,0,0)',
        highlight: 'rgba(0,0,0,0)',
        inherit: false,
      },
      hoverWidth: 0,
      selectionWidth: 0,
    },
    background: { color: '#1a1a2e' },
  };

  network = new vis.Network(container, { nodes: nodesDataset, edges: edgesDataset }, options);
  edgeState = new Map();
  nodePrevPos = new Map();
  network.on('beforeDrawing', drawSoftEdges);
  startAnimationLoop();

  network.on('click', params => {
    if (params.nodes.length > 0) showNodeDetails(params.nodes[0]);
    else clearNodeDetails();
  });
}

function showNodeDetails(nodeId) {
  const node = allNodes.find(n => n.id === nodeId);
  if (!node) return;

  const connectedEdges = allEdges.filter(e => e.from === nodeId || e.to === nodeId);
  const color = COLOR_MAP[node.group] || COLOR_MAP.default;

  let html = `<div class="node-name">${esc(node.label)}</div>`;
  html += `<span class="node-type" style="background:${color}22;color:${color};border:1px solid ${color}44">${esc(node.group)}</span>`;

  // Parse tooltip for attributes
  const lines = (node.title || '').split('\n').slice(1);
  if (lines.length > 0) {
    html += '<div style="margin-top:6px">';
    for (const line of lines) {
      if (!line.trim()) continue;
      const [k, ...rest] = line.split(':');
      html += `<div class="attr-row"><span class="attr-key">${esc(k)}:</span><span>${esc(rest.join(':').trim())}</span></div>`;
    }
    html += '</div>';
  }

  if (connectedEdges.length > 0) {
    html += `<div class="edges-title">Connections (${connectedEdges.length})</div>`;
    connectedEdges.slice(0, 10).forEach(e => {
      const dir = e.from === nodeId ? '→' : '←';
      const otherId = e.from === nodeId ? e.to : e.from;
      const other = allNodes.find(n => n.id === otherId);
      const otherLabel = other ? other.label : otherId;
      html += `<div class="edge-item">${dir} <span>${esc(e.label)}</span> ${esc(otherLabel)}</div>`;
    });
    if (connectedEdges.length > 10) html += `<div style="color:#666;margin-top:4px">+${connectedEdges.length - 10} more</div>`;
  }

  document.getElementById('node-info').innerHTML = html;
}

function clearNodeDetails() {
  document.getElementById('node-info').innerHTML = '<span style="color:#666">Click a node to see details</span>';
}

function renderLegend(nodes) {
  const types = [...new Set(nodes.map(n => n.group))].sort();
  const container = document.getElementById('legend');
  container.innerHTML = types.map(t => {
    const color = COLOR_MAP[t] || COLOR_MAP.default;
    return `<div class="legend-item"><div class="legend-dot" style="background:${color}"></div><span>${esc(t)}</span></div>`;
  }).join('') || '<span style="color:#666">No nodes</span>';
}

function updateStats(nodeCount, edgeCount) {
  document.getElementById('stats').textContent = `${nodeCount} nodes · ${edgeCount} edges`;
}

document.getElementById('search').addEventListener('input', e => {
  const q = e.target.value.trim().toLowerCase();
  if (!network || !nodesDataset) return;

  if (!q) {
    nodesDataset.update(allNodes.map(n => ({ id: n.id, opacity: 1 })));
    return;
  }

  const matched = new Set(allNodes.filter(n => n.label.toLowerCase().includes(q)).map(n => n.id));
  nodesDataset.update(allNodes.map(n => ({
    id: n.id,
    opacity: matched.has(n.id) ? 1 : 0.15,
    borderWidth: matched.has(n.id) ? 3 : 1,
  })));

  if (matched.size > 0) network.fit({ nodes: [...matched], animation: true });
});

document.addEventListener('visibilitychange', () => {
  if (document.hidden) stopAnimationLoop();
  else startAnimationLoop();
});
window.addEventListener('pagehide', stopAnimationLoop);

loadGraph();
</script>
</body>
</html>
